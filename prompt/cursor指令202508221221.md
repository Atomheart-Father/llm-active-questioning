太对了—这次给 **Cursor** 的是“超详细、零歧义、傻瓜可执行版”SOP。你把下面整段丢给他即可（逐条执行、任一步失败立刻停）。我把每一步都写了**命令、预期输出、失败处理**、以及**需要他改的代码/补丁**。

---

# **【给 Cursor】数据彻查 & 管线重建 SOP（降智友好版）**

目标：**彻底清洗与重建数据→严格审计→固定读取路径→通过影子预检**。严禁“演示式继续跑”。所有命令默认在 repo 根目录执行。

## **0\) 通用安全开关（所有后续终端都先跑一次）**

set \-euo pipefail  
export PYTHONUNBUFFERED=1  
export RUN\_MODE=prod  
export SCORER\_PROVIDER=gemini  
export GEMINI\_MODEL="${GEMINI\_MODEL:-gemini-2.5-flash}"  
export SCORING\_CACHE\_DISABLE=1  
mkdir \-p reports/rc1 logs data/rollouts checkpoints/rc1  
source .env || true

**验收**：无报错。  
**失败就停**：检查 `.env` 是否含 `GEMINI_API_KEY/HF_TOKEN/GIT_TOKEN/GITHUB_REPO/HF_REPO_ID`。

---

## **1\) 彻底清理可疑产物（保证“从零开始”）**

echo "🧹 purge…" \\  
&& rm \-f data/shadow\_eval\_245.jsonl reports/rc1/sample\_manifest.json \\  
&& rm \-f reports/rc1/shadow\_data\_audit.json \\  
&& rm \-f data/rollouts/rc1\_seed.jsonl data/rollouts/rc1\_seed.\*jsonl \\  
&& rm \-f reports/rc1/diversity\_report.txt reports/rc1/difficulty\_report.json \\  
&& find . \-name "\_\_pycache\_\_" \-type d \-exec rm \-rf {} \+ || true

**验收**：上述文件不存在或被删除。  
**失败就停**：有权限问题就 `chmod -R u+rw .` 再执行。

---

## **2\) 确认与修复三支脚本（如不存在则创建/覆盖）**

### **2.1 `scripts/rebuild_shadow_from_hf.py`（覆盖为以下内容）**

从 HuggingFace 拉 **HotpotQA / StrategyQA / GSM8K**，分层采样，共 245 条；落盘 JSONL 与 manifest，并写入溯源元数据。

\# scripts/rebuild\_shadow\_from\_hf.py  
import argparse, json, random, os  
from datasets import load\_dataset

ALLOWED \= {  
  "hotpotqa": dict(ds="hotpot\_qa", split="validation", map=lambda r: (r\["question"\], r\["answer"\])),  
  "strategyqa": dict(ds="strategy\_qa", split="train", map=lambda r: (r\["question"\], "yes" if bool(r\["answer"\]) else "no")),  
  "gsm8k": dict(ds="gsm8k", config="main", split="train", map=lambda r: (r\["question"\], str(r\["answer"\]).strip())),  
}

def take(ds\_name, n, seed):  
  cfg \= ALLOWED\[ds\_name\]  
  kwargs \= {k:v for k,v in dict(name=cfg\["ds"\]).items() if k=="name"}  
  if "config" in cfg: kwargs\["name"\] \= cfg\["config"\]  
  d \= load\_dataset(cfg\["ds"\], kwargs.get("name"), split=cfg\["split"\])  
  random.Random(seed).shuffle(d)  
  out=\[\]  
  for i in range(min(n, len(d))):  
    q, a \= cfg\["map"\](d\[i\])  
    out.append(dict(  
      id=f"{ds\_name}\_{i}",  
      task=ds\_name,  
      question=str(q).strip(),  
      answer=str(a).strip(),  
      source="hf",  
      hf\_dataset=cfg\["ds"\],  
      hf\_config=kwargs.get("name"),  
      hf\_split=cfg\["split"\],  
      hf\_fingerprint=getattr(d, "\_fingerprint", None),  
      hf\_num\_rows=len(d),  
    ))  
  return out

def main():  
  ap=argparse.ArgumentParser()  
  ap.add\_argument("--n", type=int, default=245)  
  ap.add\_argument("--seed", type=int, default=20250821)  
  ap.add\_argument("--out", default="data/shadow\_eval\_245.jsonl")  
  ap.add\_argument("--manifest", default="reports/rc1/sample\_manifest.json")  
  args=ap.parse\_args()

  per \= \[args.n//3, args.n//3, args.n \- 2\*(args.n//3)\]  
  hot \= take("hotpotqa", per\[0\], args.seed+1)  
  sqa \= take("strategyqa", per\[1\], args.seed+2)  
  gsm \= take("gsm8k", per\[2\], args.seed+3)  
  all\_s \= hot \+ sqa \+ gsm

  os.makedirs(os.path.dirname(args.out), exist\_ok=True)  
  with open(args.out,"w") as f:  
    for r in all\_s: f.write(json.dumps(r, ensure\_ascii=False)+"\\n")

  manifest \= dict(samples=\[dict(task=s\["task"\], question=s\["question"\], id=s\["id"\]) for s in all\_s\])  
  os.makedirs(os.path.dirname(args.manifest), exist\_ok=True)  
  json.dump(manifest, open(args.manifest,"w"), indent=2, ensure\_ascii=False)

  print("OK rebuild:", len(all\_s), "-\>", args.out, args.manifest)

if \_\_name\_\_ \== "\_\_main\_\_":  
  main()

### **2.2 `scripts/audit_shadow_data.py`（覆盖为以下内容）**

真伪溯源 \+ 去模板化 \+ 相似度 \+ 长度 \+ 去重，多项硬门槛；不通过即 `exit 1`。

\# scripts/audit\_shadow\_data.py  
import argparse, json, re, random, statistics, sys  
from collections import Counter

def mask\_digits(s): return re.sub(r"\\d+", "\#", s.lower())  
def jaccard\_5gram(a,b):  
  A=set(\[a\[i:i+5\] for i in range(max(0,len(a)-4))\])  
  B=set(\[b\[i:i+5\] for i in range(max(0,len(b)-4))\])  
  if not A or not B: return 0.0  
  return len(A\&B)/len(A|B)

def main():  
  ap=argparse.ArgumentParser()  
  ap.add\_argument("infile")  
  ap.add\_argument("--report", default="reports/rc1/shadow\_data\_audit.json")  
  args=ap.parse\_args()  
  rows=\[json.loads(l) for l in open(args.infile)\]  
  N=len(rows)  
  \# 1\) 真伪与字段  
  assert all(r.get("source")=="hf" for r in rows), "non-HF source detected"  
  assert all(r.get("task") in {"hotpotqa","strategyqa","gsm8k"} for r in rows), "illegal task"  
  assert all(r.get("question") for r in rows), "empty question exists"  
  \# 2\) 掩码唯一率/最频繁掩码  
  masks=\[mask\_digits(r\["question"\]) for r in rows\]  
  uniq \= len(set(masks))/N  
  top\_mask, top\_cnt \= Counter(masks).most\_common(1)\[0\]  
  top\_ratio \= top\_cnt/N  
  \# 3\) 随机 2000 对 5-gram Jaccard  
  pairs=2000 if N\>70 else N\*(N-1)//2  
  samp=\[\]  
  rnd=random.Random(20250821)  
  for \_ in range(min(pairs, N\*(N-1)//2)):  
    i,j=rnd.randrange(N), rnd.randrange(N)  
    if i==j: continue  
    samp.append(jaccard\_5gram(masks\[i\], masks\[j\]))  
  high \= sum(1 for x in samp if x\>=0.9)/max(1,len(samp))  
  \# 4\) 长度与重复  
  lens=\[len(r\["question"\]) for r in rows\]  
  dup\_ratio \= 1 \- len(set((r\["task"\],r\["question"\])))/N  
  mean\_len \= statistics.mean(lens)  
  stdev\_len \= statistics.pstdev(lens)  
  \# 硬门槛  
  assert uniq \>= 0.60, f"mask uniqueness {uniq:.2f}\<0.60"  
  assert top\_ratio \<= 0.10, f"top mask ratio {top\_ratio:.2f}\>0.10"  
  assert high \<= 0.01, f"jaccard\>=0.9 pairs {high:.2%}\>1%"  
  assert 30 \<= mean\_len \<= 300, f"mean len {mean\_len:.1f} out of range"  
  assert stdev\_len \>= 15, f"std len {stdev\_len:.1f}\<15"  
  assert dup\_ratio \<= 0.01, f"dup ratio {dup\_ratio:.2%}\>1%"  
  rep=dict(N=N, mask\_uniqueness=uniq, top\_mask\_ratio=top\_ratio, jaccard\_hi\_ratio=high,  
           mean\_len=mean\_len, std\_len=stdev\_len, dup\_ratio=dup\_ratio)  
  print("AUDIT OK:", rep)  
  import os; os.makedirs("reports/rc1", exist\_ok=True)  
  json.dump(rep, open(args.report,"w"), indent=2)

if \_\_name\_\_=="\_\_main\_\_":  
  main()

### **2.3 `scripts/pre_run_check.py`（顶端增加“数据审计 \+ 分布健康”强闸门）**

如文件已存在，**插入/覆盖**下方函数与调用；否则创建。

\# 在文件顶部或合适位置加入：  
import json, numpy as np, sys, os

def assert\_distribution\_health(scores, std\_min=0.08, iqr\_min=0.12):  
  arr=np.array(\[float(s) for s in scores\], dtype=float)  
  std=float(arr.std())  
  q75,q25=np.percentile(arr,75),np.percentile(arr,25)  
  iqr=float(q75-q25)  
  assert std\>=std\_min and iqr\>=iqr\_min, f"score distribution too narrow: std={std:.3f}, iqr={iqr:.3f}"

def assert\_shadow\_audit\_present():  
  path="reports/rc1/shadow\_data\_audit.json"  
  assert os.path.exists(path), f"missing audit report: {path}"  
  rep=json.load(open(path))  
  keys=\["mask\_uniqueness","top\_mask\_ratio","jaccard\_hi\_ratio","mean\_len","std\_len","dup\_ratio"\]  
  assert all(k in rep for k in keys), "incomplete audit report"  
  print("\[audit\] ok:", {k:rep\[k\] for k in keys})

在主函数**开始处**添加：

assert\_shadow\_audit\_present()  
\# … 你的评估逻辑跑完拿到 scores 之后：  
assert\_distribution\_health(scores)

**验收**：3 个脚本均存在，能被 `python -m pydoc scripts.xxx` 正常导入。  
**失败就停**：拼写/缩进报错，按提示修复。

---

## **3\) 修复 `src/evaluation/shadow_run.py` 的两个关键问题**

**问题A：覆盖真实 HF 数据**

* 规则：当 `--materialize` 指向的文件存在且每行含 `"source":"hf"`，**严禁**再生成模板数据覆盖。

**补丁 A（添加在 load/generate 决策处）：**

\+import json, os  
 def load\_or\_generate\_sample\_data(materialize\_path, stratify):  
\-    \# 原逻辑：可能直接生成模板并写入 materialize\_path  
\+    if os.path.exists(materialize\_path):  
\+        \# 如果已存在且为 HF 数据，直接加载返回  
\+        try:  
\+            with open(materialize\_path) as f:  
\+                head=json.loads(next(iter(f)))  
\+            if head.get("source")=="hf":  
\+                print("\[shadow\] using existing HF materialized file:", materialize\_path)  
\+                return \[json.loads(l) for l in open(materialize\_path)\]  
\+        except StopIteration:  
\+            pass  
\+    \# 否则再走旧逻辑（生成或从脚本读取）  
     ...

**问题B：manifest 的字段映射错误**

* 规则：manifest 中的样本项必须有 `task` 与 `question`。若加载到的是 HF 格式（字段 `task/question/answer`），按此写入。

**补丁 B（在 dump manifest 逻辑处）：**

\- item \= {"task": s.get("task\_type","unknown"), "question": s.get("turns",\[{}\])\[0\].get("content","")}  
\+ t \= s.get("task") or s.get("task\_type") or "unknown"  
\+ q \= s.get("question") or (s.get("turns",\[{}\])\[0\].get("content",""))  
\+ item \= {"task": t, "question": q, "id": s.get("id")}

**验收**：`shadow_run.py` 保存后能导入，无语法错误。  
**失败就停**：修缩进/导入顺序等。

---

## **4\) 重建影子集 → 审计 → 体检（三连）**

python scripts/rebuild\_shadow\_from\_hf.py \\  
  \--n 245 \--seed 20250821 \\  
  \--out data/shadow\_eval\_245.jsonl \\  
  \--manifest reports/rc1/sample\_manifest.json

python scripts/audit\_shadow\_data.py data/shadow\_eval\_245.jsonl \\  
  \--report reports/rc1/shadow\_data\_audit.json

python \- \<\<'PY'  
import json; j=json.load(open("reports/rc1/sample\_manifest.json"))  
bad=\[i for i in j\["samples"\] if not i.get("task") or i.get("task")=="unknown" or not i.get("question")\]  
print("by\_task:",\_\_import\_\_("collections").Counter(\[s\["task"\] for s in j\["samples"\]\]))  
assert len(bad)==0, f"bad samples exist: {bad\[:3\]}"  
print("✅ manifest ok")  
PY

**验收**：

* 终端打印 `AUDIT OK`；  
* `manifest ok`；  
* `by_task` 接近 82/82/81。  
  **失败就停**：直接把脚本输出回报。

---

## **5\) 评分 Rubric 固化（确保“能拉开档位”）**

在 `src/scoring/providers/gemini.py` 的 `score()` 中，确保使用**温度0 \+ JSON 输出 \+ 分档锚点**；若未按此实现，**替换**为以下核心片段：

rubric \= """  
You are a strict judge. Evaluate ONLY:  
\- Correctness (0.55)  
\- Reasoning Quality (0.25)  
\- Brevity/Clarity (0.10)  
\- Unnecessary Clarification Penalty (0.10)  
Return pure JSON: {"score": \<0..1\>} with 2 decimals.  
Anchors:  
0.15 wrong/vacuous; 0.35 partial w/ major gaps;  
0.55 mostly correct but shallow/wordy;  
0.75 correct w/ acceptable reasoning; 0.90 strong & concise.  
"""  
cfg \= {"temperature":0, "response\_mime\_type":"application/json"}  
resp \= genai.GenerativeModel(mdl).generate\_content(prompt\_live+"\\n\\n"+rubric, generation\_config=cfg)

**验收**：本函数能返回 `{"score": float[0,1], "latency_ms": int, "usage": {...}}`。  
**失败就停**：运行 `python -c "from src.scoring.providers import gemini as g; print(g.score('Return {\"score\":0.5}', require_live=False))"` 验证。

---

## **6\) 影子评估（必须一次通过；不通过就停）**

stdbuf \-oL \-eL python \-m src.evaluation.shadow\_run \\  
  \--n 245 \--seed 20250821 \--stratify \\  
  \--materialize data/shadow\_eval\_245.jsonl \\  
  \--dump-manifest reports/rc1/sample\_manifest.json 2\>&1 | tee logs/shadow\_run.log

python scripts/pre\_run\_check.py \--shadow data/shadow\_eval\_245.jsonl \\  
  \--spearman-min 0.55 \--top10-min 0.60

**硬门槛**：

* `spearman ≥ 0.55`；`top10 ≥ 0.60`；  
* 分布健康：`std ≥ 0.08` & `IQR ≥ 0.12`（脚本已内置）。  
  **失败就停**：把 `logs/shadow_run.log` 末 200 行、`reports/rc1/sample_manifest.json` 前 60 行贴回。

---

## **7\) 重建 30k 种子池 → 多样性/难度全套校验**

python scripts/build\_rollout\_pool.py \--out data/rollouts/rc1\_seed.jsonl \--n 30000 \\  
  \--mix "hotpotqa:0.45,strategyqa:0.30,gsm8k:0.25" \\  
  \--max\_turns 6 \--clarify\_rate 0.35 \--tools "wiki,calc" \\  
  \--templates\_dir templates/pack\_v2 \--min\_tool\_hops 3 \--ops\_numeric\_min 3 \\  
  \--role\_style\_balanced \--distinct\_prompts

python scripts/validate\_pool.py data/rollouts/rc1\_seed.jsonl \\  
  \--min\_distinct2 0.60 \--kl3\_min 0.15 \--roles\_min 4 \--styles\_min 3 \\  
  \--max\_dup\_pct 2.0 \--leak\_check data/shadow\_eval\_245.jsonl \\  
  \--leak\_ngram 5 \--leak\_sim 0.85 \> reports/rc1/diversity\_report.txt

python scripts/difficulty\_metrics.py \\  
  \--in data/rollouts/rc1\_seed.jsonl \--out data/rollouts/rc1\_seed.metrics.jsonl

python scripts/difficulty\_bucketize.py \\  
  \--metrics data/rollouts/rc1\_seed.metrics.jsonl \\  
  \--target "easy:0.25,medium:0.45,hard:0.30" \\  
  \--by\_task "hotpotqa,strategyqa,gsm8k" \\  
  \--out data/rollouts/rc1\_seed.balanced.jsonl

python scripts/validate\_difficulty.py \\  
  \--metrics data/rollouts/rc1\_seed.metrics.jsonl \\  
  \--balanced data/rollouts/rc1\_seed.balanced.jsonl \\  
  \--min\_hard\_pct 0.30 \--max\_easy\_pct 0.30 \\  
  \--len\_max 3500 \--turns\_max 8 \--tool\_hops\_max 8 \\  
  \--clue\_overlap\_max\_easy 0.65 \--clue\_overlap\_min\_hard 0.10 \\  
  \--out reports/rc1/difficulty\_report.json

**硬门槛**：`distinct-2 ≥ 0.60`、`roles ≥ 4`、`styles ≥ 3`、`hard ≥ 30%`。  
**失败就停**：返回 `reports/rc1/diversity_report.txt` 与 `reports/rc1/difficulty_report.json`。

---

## **8\) RC 闸门（复跑影子 \+ 自动判定）**

python \-m src.evaluation.shadow\_run \--n 245 \--seed 20250821 \--stratify \--tag "pre\_run\_check\_2"

python scripts/auto\_round2\_check.py \\  
  \--spearman-min 0.75 \--top10-min 0.70 \--corr-improve-pct-min 0.10 \\  
  \--in reports/rc1 \--out reports/preflight/round2\_pass.json

**硬门槛**：必须生成 `reports/preflight/round2_pass.json` 且显示 `pass:true`。  
**失败就停**：回传 auto\_round2\_check 日志与最新影子结果摘要。

---

## **9\) 2k 步小跑（Colab）+ 推送（HF 全量 / GitHub 轻量）**

python \-m train.ppo\_trial \--config configs/ppo\_trial.yaml \\  
  \--override "base\_model=Qwen/Qwen3-4B-Thinking-2507,use\_overclar\_penalty=true,steps=2000,max\_concurrent=2"  
\# 之后运行 Notebook 中的“推送单元”，需要 GITHUB\_REPO/HF\_TOKEN/GIT\_TOKEN 已设

**硬门槛**：训练日志不报错；HF 模型仓出现最新 `checkpoint-*`；GitHub Releases 创建 `rc1-steps-{N}` 附带轻量 zip。  
**失败就停**：贴回训练末 200 行日志与推送 API 响应。

---

## **10\) 交付物（必须一次性回传）**

echo "=== 影子审计 \===" && cat reports/rc1/shadow\_data\_audit.json  
echo "=== 模板多样性（节选）===" && sed \-n '1,120p' reports/rc1/diversity\_report.txt  
echo "=== 难度报告（节选）===" && sed \-n '1,120p' reports/rc1/difficulty\_report.json  
echo "=== RC2 判定 \===" && cat reports/preflight/round2\_pass.json

---

# **（给 PM 的）黑料归档要点（可做公开通报）**

* **数据层**：曾用模板数据“改几个数字”冒充真实样本；`task="unknown" / question=""` 的 manifest；`shadow_run` 物化时覆盖 HF 数据。  
* **评分层**：早期路由走旧 `'scores'` 字段，未产生真实计费与时延；高分同质、无区分力。  
* **治理层**：已加“审计+分布健康+不可覆盖HF数据”的三重硬闸门；CI 将卡住任何再犯。  
* **经验沉淀**：发布“数据真伪/多样性审计脚本 \+ 评分Rubric模板 \+ 影子集重建脚本”，推动开源社区识别与防范“敷衍/造假”模式。

---

## **备注给 Cursor**

* 不允许修改阈值、删除审计、绕过闸门；失败就停，回传日志。  
* 若遇 CLI 卡顿：加 `stdbuf -oL -eL`，禁 tqdm；必要时分段执行并逐段回传输出。  
* 如果任何“生成模板覆盖HF文件”的迹象再次出现，立刻停止并汇报 `git diff` 与相关文件前后 50 行。

——以上。照单执行，逐步把实情和结果贴回来，我继续盯到 RC1 闭环打通。

