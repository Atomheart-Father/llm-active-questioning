好的。把下面这份**执行指令**直接交给 Cursor。目标：**让 probe\_scorer 强制走新版 Gemini 适配器、彻底消灭旧 `'scores'` 路径、写入账本**；全部打通后再继续既定流程。任一步失败**立即停止并上报**。

---

# **【给 Cursor】修复探针失败：强制切到新版 Gemini 适配器 \+ 账本打通**

## **0\) 安全环境（全程开启）**

set \-euo pipefail  
export RUN\_MODE=prod  
export SCORER\_PROVIDER=gemini  
export GEMINI\_MODEL="${GEMINI\_MODEL:-gemini-2.5-flash}"  
export SCORING\_CACHE\_DISABLE=1            \# 禁缓存，确保真调用  
mkdir \-p reports/rc1

## **1\) 定位问题：打印探针实际用的“评分函数”**

目的：确认 `scripts/probe_scorer.py` 现在到底在调用哪个模块（防止还走旧路由）。

python \- \<\<'PY'  
import inspect, os  
from importlib import import\_module  
m \= import\_module("scripts.probe\_scorer")  
func \= getattr(m, "score\_once", None) if hasattr(m,"score\_once") else None  
print("probe module:", m.\_\_file\_\_)  
if func:  
    print("score\_once from:", inspect.getsourcefile(func))  
else:  
    print("score path unknown; we will hardwire Gemini adapter next.")  
PY

## **2\) 硬切新版适配器（最小改动，先保通）**

把探针脚本改成**直接调用**我们新版 `src/scoring/providers/gemini.py:score`，并**写账本**。

**补丁一：`scripts/probe_scorer.py`**

\--- a/scripts/probe\_scorer.py  
\+++ b/scripts/probe\_scorer.py  
@@  
\-import whatever\_old\_router as router  
\+import os, json, time, uuid, pathlib  
\+from src.scoring.providers import gemini as gsc  
\+  
\+LEDGER \= pathlib.Path("reports/rc1/scoring\_ledger.jsonl")  
\+LEDGER.parent.mkdir(parents=True, exist\_ok=True)  
\+  
\+def \_write\_ledger(rec: dict):  
\+    with LEDGER.open("a") as f:  
\+        f.write(json.dumps(rec, ensure\_ascii=False) \+ "\\n")  
@@  
\-def score\_once(prompt):  
\-    res \= router.score(prompt)   \# 旧路径：会期望 'scores'  
\-    return res  
\+def score\_once(prompt: str):  
\+    res \= gsc.score(prompt, model=os.getenv("GEMINI\_MODEL","gemini-2.5-flash"), require\_live=True)  
\+    \# 期望输出：{'score':float\[0,1\], 'latency\_ms':int, 'usage':{...}, 'raw':str}  
\+    assert 0.0 \<= float(res\["score"\]) \<= 1.0  
\+    bill \= (res\["usage"\].get("total\_tokens")  
\+            or (res\["usage"\].get("prompt\_tokens",0) \+ res\["usage"\].get("completion\_tokens",0)))  
\+    rec \= {  
\+        "ts": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),  
\+        "provider": "gemini",  
\+        "billable\_tokens": bill,  
\+        "latency\_ms": res\["latency\_ms"\],  
\+        "status": "ok",  
\+        "cache\_hit": False,  
\+        "request\_id": str(uuid.uuid4())  
\+    }  
\+    \_write\_ledger(rec)  
\+    return res

说明：这一步**绕开所有旧路由**，保证现在就能“真连通 \+ 记账”。后续再把路由恢复到统一入口。

## **3\) 消灭旧 `'scores'` 依赖（避免其它脚本再炸）**

列出仓库里还在用 `'scores'` 的地方并统一改成 `.get("score")`：

echo "🔍 搜索旧字段 'scores' 的使用点"  
grep \-R \--line-number \--exclude-dir=.git \--exclude=\*.ipynb \-E "\[\\"'\]scores\[\\"'\]" src scripts || true

对出现的文件，做如下通用替换逻辑（示意）：

\- s \= resp\["scores"\]\[0\]  
\+ s \= resp.get("score", resp.get("scores",\[None\])\[0\] if isinstance(resp.get("scores"), (list,tuple)) else resp.get("scores"))  
\+ \# 并将 s 归一化到 \[0,1\]（若已有统一入口则可省略）

若文件名为 `src/evaluation/advanced_reward_system.py` 的 `_parse_gemini_response`，直接改为**调用新版适配器**（与 probe 同步）。

## **4\) 清理缓存 & 字节码，防止走老版本**

find . \-name "\_\_pycache\_\_" \-type d \-exec rm \-rf {} \+ || true

## **5\) 探针复测（必须一次性通过）**

rm \-f reports/rc1/scoring\_ledger.jsonl || true  
python \-u scripts/probe\_scorer.py \--n 8 \--provider gemini \--live  
python \-u scripts/assert\_not\_simulated.py \--cache\_hit\_lt 0.90  
python \- \<\<'PY'  
import json,statistics,sys  
rows=\[json.loads(l) for l in open("reports/rc1/scoring\_ledger.jsonl")\]  
lat=\[r.get("latency\_ms") or 0 for r in rows if r.get("latency\_ms") is not None\]  
bill=\[r.get("billable\_tokens") or 0 for r in rows\]  
assert len(rows)==8 and all(r.get("status")=="ok" for r in rows), "hard gate not met"  
assert sum(1 for b in bill if b==0)==0, "zero billable found"  
print("✅ probe ok; p50 latency:", statistics.median(lat))  
PY

**如果失败**：把 `reports/rc1/gemini_probe_raw.json`、`reports/rc1/scoring_ledger.jsonl` 末 20 行、以及异常栈贴回，**立即停止**。

## **6\) 恢复统一路由（确保新版适配器被路由调用）**

**补丁二：`src/scoring/provider_router.py`**

\--- a/src/scoring/provider\_router.py  
\+++ b/src/scoring/provider\_router.py  
@@  
 import os  
\-if os.getenv("SCORER\_PROVIDER","").lower() \!= "gemini":  
\-    raise RuntimeError("RC1 仅允许 SCORER\_PROVIDER=gemini")  
\-from old\_impl import score as score\_impl  
\+if os.getenv("SCORER\_PROVIDER","").lower() \!= "gemini":  
\+    raise RuntimeError("RC1 仅允许 SCORER\_PROVIDER=gemini")  
\+from src.scoring.providers.gemini import score as score\_impl  
@@  
 def score(prompt: str, \*\*kw):  
     return score\_impl(prompt, \*\*kw)

再次跑探针，确认**走路由也能通过**：

python \-u scripts/probe\_scorer.py \--n 8 \--provider gemini \--live

## **7\) （可选）加一条防回归的单测/烟测**

新建 `tests/test_gemini_probe.py`：

def test\_gemini\_probe(monkeypatch):  
    import os  
    if not os.getenv("GEMINI\_API\_KEY"): return  
    from src.scoring.providers import gemini as g  
    r \= g.score("Return a JSON {\\"score\\":0.5}", require\_live=True)  
    assert 0 \<= r\["score"\] \<= 1  
    assert r\["latency\_ms"\] \> 0

执行：

pytest \-q tests/test\_gemini\_probe.py \-q || (echo "❌ probe unit failed" && exit 1\)

---

## **8\) 通过后，回到主流程（按既定指令继续）**

**影子预检 → 重建 30k 种子池（多样性/难度达标） → RC 闸门 → 2k 小跑 → HF 全量 / GH 轻量推送。**  
仍然遵守：**任一步失败即停，不做演示性继续**。

---

### **验收要点（请回传）**

* `python -u scripts/probe_scorer.py --n 8 --provider gemini --live` **一次成功**。  
* `reports/rc1/scoring_ledger.jsonl` 中 **8 条**记录：`status=ok`、`latency_ms>0`、`billable_tokens>0`。  
* `grep -R '"scores"'` 只剩测试文件或已删除（截图/清单）。

通过后你就继续跑影子/难度与后续步骤；若任一环节卡住，按“失败即停”的规矩，把**命令输出 \+ 最末 50 行日志 \+ 账本末 20 行**贴回，我会继续盯。

